#!/bin/bash
# Infrastructure overview — shows status of all environments
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
ROOT_DIR="$(dirname "$SCRIPT_DIR")"

envs=(test preprod prod)
creds_dir="$ROOT_DIR/credentials"
tf_envs="$ROOT_DIR/terraform/environments"
ansible_inv="$ROOT_DIR/ansible/inventory"

S3_BUCKET="accoreboot-tfstate"
S3_ENDPOINT="https://s3.gra.io.cloud.ovh.net"

# ── Colors & symbols ──
G='\033[0;32m' R='\033[0;31m' Y='\033[0;33m' C='\033[0;36m' D='\033[0;90m'
B='\033[1m' N='\033[0m'

icon_ok="${G}✓${N}" icon_no="${R}✗${N}" icon_warn="${Y}?${N}" icon_skip="${D}·${N}"

# ── Helpers ──
load_sops_file() {
  local file="$1"
  while IFS='=' read -r key value; do
    [[ -z "$key" || "$key" == \#* ]] && continue
    export "$key=$value"
  done < <(sops -d --output-type dotenv "$file" 2>/dev/null)
}

load_env_secrets() {
  local env="$1"
  if [ -f "$creds_dir/common.enc.env" ] && [ -f "$creds_dir/$env.enc.env" ]; then
    load_sops_file "$creds_dir/common.enc.env"
    load_sops_file "$creds_dir/$env.enc.env"
    return 0
  fi
  return 1
}

section() {
  echo ""
  echo -e "${B}$1${N}"
}

status_line() {
  local icon="$1" label="$2" detail="${3:-}"
  if [ -n "$detail" ]; then
    printf "  %b  %-28s %b\n" "$icon" "$label" "$detail"
  else
    printf "  %b  %s\n" "$icon" "$label"
  fi
}

# Check TCP connectivity (no external tools needed)
tcp_check() {
  local host="$1" port="$2" timeout="${3:-3}"
  timeout "$timeout" bash -c "echo >/dev/tcp/$host/$port" 2>/dev/null
}

# ══════════════════════════════════════════════════════════════════════════════

echo -e "${B}AccoReboot — Infrastructure Overview${N}"

# ── 1. Prerequisites ──
section "Prerequisites"
for cmd in terraform ansible-playbook sops openstack docker curl; do
  if command -v "$cmd" &>/dev/null; then
    ver=$($cmd --version 2>/dev/null | head -1 | grep -oP '[\d]+\.[\d]+\.[\d]+' | head -1)
    status_line "$icon_ok" "$cmd" "${D}$ver${N}"
  else
    status_line "$icon_no" "$cmd" "${R}not installed${N}"
  fi
done
if [ -f ~/.config/sops/age/keys.txt ]; then
  status_line "$icon_ok" "age key"
else
  status_line "$icon_no" "age key" "${R}~/.config/sops/age/keys.txt missing${N}"
fi

# ── 2. Credentials ──
section "Credentials"
if [ -f "$creds_dir/common.enc.env" ]; then
  status_line "$icon_ok" "common.enc.env"
else
  status_line "$icon_no" "common.enc.env" "copy from .example"
fi
for e in "${envs[@]}"; do
  if [ -f "$creds_dir/$e.enc.env" ]; then
    status_line "$icon_ok" "$e.enc.env"
  else
    status_line "$icon_skip" "$e.enc.env" "${D}not configured${N}"
  fi
done

# ── 3. S3 State Bucket ──
section "S3 State Bucket"
if [ -f "$creds_dir/common.enc.env" ]; then
  load_sops_file "$creds_dir/common.enc.env"
  if aws s3 ls "s3://$S3_BUCKET" --endpoint-url "$S3_ENDPOINT" --region gra &>/dev/null; then
    status_line "$icon_ok" "$S3_BUCKET" "${D}$S3_ENDPOINT${N}"
    for e in "${envs[@]}"; do
      if aws s3 ls "s3://$S3_BUCKET/$e/terraform.tfstate" --endpoint-url "$S3_ENDPOINT" --region gra &>/dev/null; then
        size=$(aws s3 ls "s3://$S3_BUCKET/$e/terraform.tfstate" --endpoint-url "$S3_ENDPOINT" --region gra 2>/dev/null | awk '{print $3}')
        status_line "$icon_ok" "  $e/terraform.tfstate" "${D}${size}B${N}"
      else
        status_line "$icon_skip" "  $e/terraform.tfstate" "${D}no state${N}"
      fi
    done
  else
    status_line "$icon_no" "$S3_BUCKET" "bucket not found or no credentials"
  fi
else
  status_line "$icon_no" "$S3_BUCKET" "cannot check (no common credentials)"
fi

# ── 4. Per-environment details ──
for e in "${envs[@]}"; do
  section "Environment: $e"

  ip="" db_host="" db_port="" power=""

  if [ ! -f "$creds_dir/$e.enc.env" ]; then
    status_line "$icon_skip" "Not configured" "${D}(no credentials)${N}"
    continue
  fi

  # Load inventory variables (generated by terraform apply)
  if [ -f "$ansible_inv/$e.ini" ]; then
    ip=$(grep 'ansible_host=' "$ansible_inv/$e.ini" | head -1 | sed 's/.*ansible_host=//')
    db_host=$(grep 'db_host=' "$ansible_inv/$e.ini" | head -1 | sed 's/.*db_host=//')
    db_port=$(grep 'db_port=' "$ansible_inv/$e.ini" | head -1 | sed 's/.*db_port=//')
  fi

  # Load secrets for OpenStack queries
  load_env_secrets "$e" || true

  # ── Compute ──
  echo -e "  ${B}Compute${N}"
  if [ -n "$ip" ]; then
    power=$(openstack server show "$e-backend" -f value -c "OS-EXT-STS:power_state" 2>/dev/null || echo "")
    os_status=$(openstack server show "$e-backend" -f value -c status 2>/dev/null || echo "")
    case "$power" in
      1)  status_line "$icon_ok" "$e-backend" "${G}$os_status${N}  ${C}$ip${N}" ;;
      4)  status_line "$icon_warn" "$e-backend" "${Y}SHUTOFF${N}" ;;
      "") status_line "$icon_warn" "$e-backend" "${Y}unreachable${N}  ${D}$ip${N}" ;;
      *)  status_line "$icon_warn" "$e-backend" "${Y}power_state=$power${N}" ;;
    esac
  else
    status_line "$icon_no" "$e-backend" "${D}no inventory (run: make apply ENV=$e)${N}"
  fi

  # ── Managed PostgreSQL ──
  echo -e "  ${B}PostgreSQL${N}"
  if [ -n "$db_host" ]; then
    if [ -n "$ip" ] && [ "$power" = "1" ]; then
      # DB is IP-restricted to the instance — check via SSH
      db_ok=$(ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 -o BatchMode=yes \
        -i ~/.ssh/id_ed25519 ubuntu@"$ip" \
        "timeout 3 bash -c 'echo >/dev/tcp/$db_host/$db_port' 2>/dev/null && echo ok" 2>/dev/null || echo "")
      if [ "$db_ok" = "ok" ]; then
        status_line "$icon_ok" "$e-postgresql" "${G}reachable${N}  ${D}$db_host:$db_port${N}"
      else
        status_line "$icon_warn" "$e-postgresql" "${Y}unreachable${N}  ${D}$db_host:$db_port${N}"
      fi
    else
      status_line "$icon_skip" "$e-postgresql" "${D}cannot check (instance down)${N}  ${D}$db_host:$db_port${N}"
    fi
  else
    status_line "$icon_no" "$e-postgresql" "${D}not provisioned${N}"
  fi

  # ── Services ──
  echo -e "  ${B}Services${N}"
  if [ -n "$ip" ] && [ "$power" = "1" ]; then
    containers=$(ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 -o BatchMode=yes \
      -i ~/.ssh/id_ed25519 ubuntu@"$ip" \
      "docker ps -a --format '{{.Names}}|{{.Status}}' 2>/dev/null" 2>/dev/null || echo "")

    if [ -n "$containers" ]; then
      expected_services=(api emqx powersync caddy)
      for svc in "${expected_services[@]}"; do
        line=$(echo "$containers" | grep -i "$svc" | head -1)
        if [ -n "$line" ]; then
          name=$(echo "$line" | cut -d'|' -f1)
          svc_status=$(echo "$line" | cut -d'|' -f2)
          if echo "$svc_status" | grep -qi "(healthy)"; then
            status_line "$icon_ok" "$name" "${G}$svc_status${N}"
          elif echo "$svc_status" | grep -qi "^Up"; then
            status_line "$icon_ok" "$name" "${G}$svc_status${N}"
          else
            status_line "$icon_warn" "$name" "${Y}$svc_status${N}"
          fi
        else
          status_line "$icon_no" "$svc" "${R}not running${N}"
        fi
      done
    else
      status_line "$icon_warn" "Cannot reach Docker" "${D}SSH failed or Docker not ready${N}"
    fi
  elif [ -n "$ip" ]; then
    status_line "$icon_skip" "Skipped" "${D}instance not running${N}"
  else
    status_line "$icon_skip" "Skipped" "${D}no instance${N}"
  fi

  # ── Endpoints ──
  if [ -n "$ip" ] && [ "$power" = "1" ]; then
    echo -e "  ${B}Endpoints${N}"
    health=$(curl -sf --connect-timeout 3 "http://$ip/health" 2>/dev/null || echo "")
    if [ -n "$health" ]; then
      status_line "$icon_ok" "/health" "${G}ok${N}  ${D}http://$ip${N}"
    else
      status_line "$icon_no" "/health" "${R}unreachable${N}  ${D}http://$ip${N}"
    fi
    jwks=$(curl -sf --connect-timeout 3 "http://$ip/.well-known/jwks.json" 2>/dev/null || echo "")
    if [ -n "$jwks" ]; then
      status_line "$icon_ok" "/.well-known/jwks.json" "${G}ok${N}"
    else
      status_line "$icon_no" "/.well-known/jwks.json" "${R}unreachable${N}"
    fi
  fi
done

echo ""
